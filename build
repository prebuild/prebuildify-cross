#!/bin/bash

ARGUMENTS="$@"
CWD=$(pwd)
# https://stackoverflow.com/questions/59895/getting-the-source-directory-of-a-bash-script-from-within
DIRNAME="$(dirname "$(readlink -f "$0")")"

# with help from https://stackoverflow.com/a/29754866,

# saner programming env: these switches turn some bugs into errors
set -o errexit -o pipefail -o noclobber -o nounset

DOCKER="docker"
set +e
if ! $DOCKER ps >/dev/null; then
  echo "error connecting to docker:"
  $DOCKER ps
  exit 1
fi
set -e

! getopt --test > /dev/null 
if [[ ${PIPESTATUS[0]} -ne 4 ]]; then
    echo "Sorry, `getopt --test` failed in this environment."
    exit 1
fi

OPTIONS=hi:o:t:n:
LONGOPTS=help,input:,output:,target:,name:

# -use ! and PIPESTATUS to get exit code with errexit set
# -temporarily store output to be able to check for errors
# -activate quoting/enhanced mode (e.g. by writing out “--options”)
# -pass arguments only via   -- "$@"   to separate them correctly
! PARSED=$(getopt --options=$OPTIONS --longoptions=$LONGOPTS --name "$0" -- "$@")
if [[ ${PIPESTATUS[0]} -ne 0 ]]; then
    # e.g. return value is 1
    #  then getopt has complained about wrong arguments to stdout
    exit 2
fi
# read getopt’s output this way to handle the quoting right:
eval set -- "$PARSED"

HELP=n 
TARGET=-
INPUT="${CWD}" OUTPUT=prebuilds
NAME=- 
while true; do
    case "$1" in
        -h|--help)
            HELP=y
            shift
            ;;
        -i|--input)
            INPUT="$2"
            shift 2
            ;;
        -o|--output)
            OUTPUT="$2"
            shift 2
            ;;
        -t|--target)
            TARGET="$2"
            shift 2
            ;;
        -n|--name)
            NAME="$2"
            shift 2
            ;;
        --)
            shift
            break
            ;;
        *)
            echo "Programming error"
            exit 3
            ;;
    esac
done

if
  [ "${HELP}" == "y" ] || \
  [ "${TARGET}" == "-" ]
then
  cat >&2 <<EOF
Usage:
  prebuild-cross [options]

  Arguments:

    --target <target>: **required** cross-compilation target 
        (see https://github.com/dockcross/dockcross#cross-compilers)
    --input <path>: _optional_ directory of input image spec (default: cwd)
    --output <path>: _optional_ directory to output build results (default: prebuilds)
    --name <name>: _optional_ name of image

  Flags:

    -h, --help: show this usage

  Examples:

    prebuild-cross --target linux-armv7
EOF
  exit 1
fi

if [[ "${INPUT}" != /* ]]
then
  INPUT="${CWD}/${INPUT}"
fi

if [[ "${OUTPUT}" != /* ]]
then
  OUTPUT="${CWD}/${OUTPUT}"
fi

echo input $INPUT
echo output $OUTPUT

if [ "${NAME}" == "-" ]
then
  NAME="$(basename "${INPUT}")"
fi

case "${TARGET}" in
  "android-arm")
    ARCH="arm"
    PLATFORM="android"
    ;;
  "android-arm64")
    ARCH="arm64"
    PLATFORM="android"
    ;;

  "linux-arm64")
    ARCH="arm64"
    PLATFORM="linux"
    ;;
  "linux-armv5"|"linux-armv6"|"linux-armv7")
    ARCH="arm"
    PLATFORM="linux"
    ;;

  "linux-x64")
    ARCH="x64"
    PLATFORM="linux"
    ;;
  "linux-x86")
    ARCH="x32"
    PLATFORM="linux"
    ;;

  "windows-x64")
    ARCH="x64"
    PLATFORM="windows"
    ;;
  "windows-x86")
    ARCH="x32"
    PLATFORM="windows"
    ;;

  *)
    echo "unknown target!" "${TARGET}"
    exit 2
    ;;
esac

IMAGE_NAME=${BASE_IMAGE_NAME:-prebuild-cross}
CONTAINER_NAME=${CONTAINER_NAME:-prebuild-cross-work-${TARGET}}

CONTAINER_RUNNING=$($DOCKER ps --filter name="$CONTAINER_NAME" -q)
if [ "$CONTAINER_RUNNING" != "" ]; then
  $DOCKER stop ${CONTAINER_NAME} > /dev/null
fi

CONTAINER_EXISTS=$($DOCKER ps -a --filter name="$CONTAINER_NAME" -q)
if [ "$CONTAINER_EXISTS" != "" ]; then
  $DOCKER rm -v "${CONTAINER_NAME}"
fi

function cleanup {
  echo 'got EXIT signal... please wait'

  CONTAINER_RUNNING=$($DOCKER ps --filter name="${CONTAINER_NAME}" -q)
  if [ "${CONTAINER_RUNNING}" != "" ]; then
    $DOCKER stop ${CONTAINER_NAME} > /dev/null
  fi

  CONTAINER_EXISTS=$($DOCKER ps -a --filter name="${CONTAINER_NAME}" -q)
  if [ "${CONTAINER_EXISTS}" != "" ]; then
    $DOCKER rm -v ${CONTAINER_NAME} > /dev/null
  fi
}

trap cleanup EXIT

# build target image
$DOCKER build \
  --build-arg TARGET="${TARGET}" \
  -t ${IMAGE_NAME}:${TARGET} \
  ${DIRNAME}

$DOCKER run \
  --name "${CONTAINER_NAME}" \
  -v "${INPUT}:/app/input" \
  --env NAME="${NAME}" \
  --env ARCH="${ARCH}" \
  --env PREBUILD_ARCH="${ARCH}" \
  --env PREBUILD_PLATFORM="${PLATFORM}" \
  ${IMAGE_NAME}:${TARGET} \
  bash -e -o errexit -o pipefail -o noclobber -o nounset -c "
    cd /app; ./build-in-docker ${ARGUMENTS};
  "
time $DOCKER logs "${CONTAINER_NAME}" --follow || true &
wait "$!"

echo "copying results from output/"
$DOCKER cp "${CONTAINER_NAME}":/app/output/. "${OUTPUT}"
ls -lah "${OUTPUT}"

echo "Done! Your prebuilds should be in ${OUTPUT}"
